# Body

**Topic**: The "Solarwinds" attack and farm-to-table methods in the development process - Mitigating disasters through supply-chain security

## The SolarWinds Attack

On 13 December 2020, FireEye, a US-based cybersecurity company, detected a large supply chain attack directed at customers of SolarWinds using their Orion monitoring and management solution. The actors of the attack, which are now presumed to be of Russian origin, were able to gain access to data of sever high-profile private and public institutions. While the attack was made apparent by late 2020, it has been running since at least Spring 2020, resulting in widespread lateral movement and data theft.

The backdoor was built into a digitally signed component of the Orion platform (`SolarWinds.Orion.Core.BusinessLayer.dll`) which communicates with external servers using HTTP. After an initial dormant period, the Trojan is able to receive and execute commands such as transferring and executing files, profiling a system, disabling services and issuing reboots from command and control infrastructure; traffic is obfuscated as by masquerading as telemetry communications similar in structure to the Orion Improvement Program. In addition to these obfuscation methods, it is sandbox-aware to evade detection by anti-malware tools and increase the threshold required to do forensics.

In order to deliver the malware to users of SolarWinds Orion, the supply chain was attacked. The attackers were able to compromise SolarWinds' private keys and digitally sign a trojanized version of a Windows Installer Patch file, which was distributed using the existing update infrastructure and, after the update process, was loaded by the host process. Signature checks did not fail due to the private key compromise. Attacks were than able to connect from the malware to command and control infrastructure by resolving a subdomain's CNAME record and designing their API to be similar to the legitimate SolarWinds API.

## Overview of Supply Chain Security

While supply chain attacks are not a new occurrence, the SolarWinds has forced both developers and security analysts to take the subject more seriously. Historically, most software did not have a particularly complex supply chain; software was limited in size, function and audience, organizations had their own developers and created, for the most part, their own software. Modern software development has however lead to a strong increase in supply chain complexity, as modern software is large enough for it not be manageable by a single organization and the latter deciding to also export previously internal software.

As a result, modern software development is at its core mostly about _assembly_ of existing software, which leads to very long supply chains. A typical "Web 2.0" application could for example include an app server, HTTP server, XML parser, C libraries & compiler, all of which also have their own supply chains. In recent years, in addition to toolchain corruption (such as in the case of XCodeGhost) becoming more and more of an issue, both popular COTS and FLOSS have shown software issues affecting software released over multiple years (such as for example the "Heartbleed" or "Shellshock" vulnerabilities). In addition to these software components affecting a software product, the usage of generated data from tools such as TensorFlow or PyTorch, as well as the use publically available data such as that from Data.gov and Google Open Images leads to new attack vectors on the software supply chain.

As a result, the interest in means to reduce the risk factors of software supply chains has risen in recent years. Simple ways to start reducing could, for example, include enforcing rules for suppliers so that they start to follow best practices too, internally ensuring the security and validity of the delivered product by inspection, analysis of the means of delivering the product, and enforcing operational product control so that the product is used securely. From an educational perspective, notarizing the level of knowledge of employees, ensuring that non-expired education material is used and the credentials of instructors are known, can lead to a reduction in risk. When it comes to checking the suppliers, enforcing the availability or design documents, analysis of attack patterns and the usage of code signing can be used.

At the heart of many supply chain security practices lies the analysis of product distribution means. Consumers of software products meant for processing or integration (such as libraries, frameworks or tooling), inherit the consequences of bad upstream practices. As a result, a consumer must require good security practices by their supplies and asses the risk of delivered products in their used context, which the original authors might not have taken into account (such as the use of COTS without memory protection in environments such as spacecraft, where high radiation levels frequently lead to memory corruption). As a result, the usage of "unchecked" internal supplies should be reduced. This is of particular interest when it comes to integrating FLOSS into both own FLOSS and COTS, in which case the recommended way of consuming the external code is to establish a supplier. This can for example be a third party focused on FLOSS (i.e. RedHat or SUSE), which allows a similar evaluation as COTS based on supplier capability, product security, product distribution and operation product control.

## Modeling the Supply Chain

Fundamentally, software supply chains have a lot in common with physical/hardware supply chains. Supply chains are created by either deploying and using a product directly or by reproducing it as a new product in repetition, and as such traditional supply chains have risks such as late product delivery, counterfeits and human errors. Many of these risks thus also apply to software supply chains and, just like they are in traditional supply chains, must be counteracted using risk management, for which a thread model is a prerequisite. Current practices mostly follow on the classical CIA triad (confidentiality, integrity, availability), as well as some more focused factors like possession, authenticity and utility. Specifically for supply chains, the security objectives of confidentiality, (data) integrity, source authenticity, availability and non-repudiation are of utmost importance, and while organizations like NIST publish best practices, concrete models of software supply chains are still a rather new subject.

This is in part because modelling software supply chains requires two processes: Modeling both social and human behavior by modeling both the system and threats to the system. Unlike many other security-related models, these processes can't be viewed as purely technical or social, but only as a combination of the two. The basis of modeling the system is ISO 27005, which defines a thread as the potential cause of an incident that might result in harm to systems and organizations. The resulting model should express and capture as many threats as necessary and differentiate between actual threats and potential threats, where the former fulfills the requirements of intention, capability and opportunities, while the latter might lack one of the three. The detection of potential threats by the model however is important, as they can potentially be prevented by acting early.

Vulnerabilities in the supply chain can be found by analyzing the relations of the integrated elements, which each compose a threat in the system. The model presented by Al Sabbagh and Kowalski, which intents to model both the technical and social elements of supply chain security, introduces two subsystems: A dynamic model of sociotechnical changes (the "sociotechnical" system) and a static model ("security by consensus"). The social subsystem contains culture (collection of values) and structure (distribution of power), while the technical subsystem contains methods and machines, such as technical artifacts. The observation of these four subsystems (culture, structure, methods and machines) determine the security state of the system as a whole; if one part of the system changes, the others must adapt accordingly in order to maintain security (i.e. if new, younger managers arrive, the "structure" parameter might require adjustment). The security by consensus system defines layers of analysis, such as ethical, political and legal, administrative and managerial, operation, application, operating system, and hardware, which makes it possible to determine the correct layers on which to react to threats.

Both internal or external changes, whether of technical or social nature, will affect security, which requires the systematic rollout of measures. While security frameworks allow analyzing supply chain security using individual layers, only looking at the supply chain as an interconnected sociotechnical system allows reviewers to verify that the layers across the system are secured properly (as issues in one layer might for example by negated by measures in another layer). A layered approach also allows the horizontal analysis of supplier's supply chains and enforcement of measures not at the boundaries of their products and trust, but also comparison of similarity with one's own measures. Comparing the different layers of each supplier's sociotechnical systems allows for creating an integrated chain of (dis-)trust, where for example the usefulness of digital signatures for the compiler binaries is negated by compiling unsigned source code or not checking the provided binaries' signatures.

When analyzing a supply chain, six distinct processes can be found: Supplier sourcing, software development and testing, software packaging and software delivery through network (or, in the case of i.e. embedded software, software product manufacturing & physical software product delivery). During analysis, the products or artifacts which are being sent between the different processes can be the reference of checks. Both supplier sourcing and product delivery naturally link companies together, which often leads to a generic process like software packaging. In this way, both FLOSS and COTS are being transmitted from supplier sourcing to the software development and testing process, including related secrets and vulnerability information, leading to multiple resulting elements being sent to the user, over the network or physically (secrets, vulnerabilities, source and/or binary package, and the user guide).

In order to find social threats after applying this modelling process, which might exist due to human error or behavioral patterns whether intentional or not, the security by consensus model can be used. Supply can for example deny having sent a product, leading to a non-repudiation issue. Ordered software products might not arrive in time due to QA problems, leading to an availability issue; secrets of outsourced software might be disclosed by employees (such as hard-coded keys or seed values) or the user might make configuration mistakes, such as choosing very short key lengths, if the user guide (which is being distributed as part of the product through the supply chain) has been tampered with.

Technical threats in the supply chain can be analyzed too using the bottom three layers of the security by consensus model (hardware, operating system, applications). This could mean vectors such as the software supplier's storage hardware being compromised, allowing externals to inject source code into repositories or packages, outsource software repositories being breached in order to gain access to hard-coded keys (such as API keys in CI/CD environment, configured by i.e. GitLab), or compromising the download site or update system.

Countermeasures to both types of threats can be either social, technical or both. If a non-repudiation issue, such as a recipient of a software product denying receiving it, occurs, a social solution would be to require a third-party notary (on the political and legal layer), while the technical countermeasure might be to use digital signatures. To prevent injection of source code during software distribution, a social solution could be to use a third-party escrow, while the technical countermeasure could be to use a VPN, TLS-secured distribution channels or digital signatures.

## "in-toto", a Framework for Supply Chain Security

In addition to this social and technical framework, in-toto provides a technical implementation of a supply chain security system. It tries to protect against supply chain attacks based on version control systems (such as the breaches of the Linux kernel, Gentoo and Google), build environment (such as the CCleaner reach), software updaters (such as the breaches of Microsoft, Adobe, Google and various Linux distros such as Debian) and others.

Current supply chain security systems are mostly limited to securing individual steps. Technical measures include for example Git commit signing, which allows for controlling what developers can modify in a repo, reproducible builds, which enables (re-)building a package by multiple parties and ensuring a bit-by-bit identical result, and various methods of software delivery, such as APT, DNF or Flatpak. While securing the initial state is useful and increases security to a certain extent, is leaves open the possibility of modifying the result of a step and passing the modified result to the next step in a chain without the changes being noticed; in other words, there is no way to verify that the correct steps were followed in order or that the artifacts between the individual steps were not tampered with. The lack of such checks was made apparent by attacks such as the Linux Mint breach, where a web server breach enabled redirection of installation image download links, resulting in the distro's internal signature checks being breached, despite no private key compromise taking place. Also, despite fuzzers and static code analysis tools being used more and more during software development, the delivered product rarely includes information about the results of these products which the end-user can verify. In summary, this shows that solutions designed to secure individual supply chain steps cannot guarantee the security of the supply chain as a whole, and further integration is required.

in-toto provides such a wholistic approach and tries to enforce the integrity of the entire supply chain. It requires the declaration and signing of a layout defining how and by whom which steps in the development and release process are to be carried out, thus giving much greater insight into the supply chain. In addition to this, it also enables involved parties to record actions and create a signed statement for each step in the supply chain ("link metadata"), which makes each step verifiable as in checking if it has been executed appropriately and by the correct party as defined in the signed layout.
